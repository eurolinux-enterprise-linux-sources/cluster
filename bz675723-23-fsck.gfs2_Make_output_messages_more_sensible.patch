commit 94431db3595d647c196e2b518065ddc2b02cae38
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Aug 9 12:36:04 2011 -0500

    fsck.gfs2: Make output messages more sensible
    
    This patch changes several fsck output messages so that they make more
    sense.  Digging through very big and complex fsck.gfs2 output, I found
    myself lost in many occasions.  This patch makes it a lot easier to see
    what decisions are made by fsck.gfs2 and why.
    
    rhbz#675723

diff --git a/gfs2/fsck/initialize.c b/gfs2/fsck/initialize.c
index 08da24f..d7586de 100644
--- a/gfs2/fsck/initialize.c
+++ b/gfs2/fsck/initialize.c
@@ -460,14 +460,14 @@ static int init_system_inodes(struct gfs2_sbd *sdp)
 	uint64_t addl_mem_needed;
 	const char *level_desc[] = {
 		_("Checking if all rgrp and rindex values are good"),
-		_("Checking if rindex values are ascending and evenly spaced"),
+		_("Checking if rindex values may be easily repaired"),
 		_("Calculating where the rgrps should be if evenly spaced"),
 		_("Trying to rebuild rindex assuming evenly spaced rgrps"),
 		_("Trying to rebuild rindex assuming unevenly spaced rgrps"),
 	};
 	const char *fail_desc[] = {
 		_("Some damage was found; we need to take remedial measures"),
-		_("rindex is unevenly spaced: converted from gfs1 or corrupt"),
+		_("rindex is unevenly spaced: either gfs1-style or corrupt"),
 		_("rindex calculations don't match: uneven rgrp boundaries"),
 		_("Too many rgrp misses: rgrps must be unevenly spaced"),
 		_("Too much damage found: we cannot rebuild this rindex"),
@@ -513,16 +513,25 @@ static int init_system_inodes(struct gfs2_sbd *sdp)
 	 *******************************************************************/
 	log_warn( _("Validating Resource Group index.\n"));
 	for (trust_lvl = blind_faith; trust_lvl <= indignation; trust_lvl++) {
+		int ret;
+
 		log_warn( _("Level %d rgrp check: %s.\n"), trust_lvl + 1,
 			  level_desc[trust_lvl]);
 		if ((rg_repair(sdp, trust_lvl, &rgcount, &sane) == 0) &&
-		    (ri_update(sdp, 0, &rgcount, &sane) == 0)) {
+		    ((ret = ri_update(sdp, 0, &rgcount, &sane)) == 0)) {
 			log_warn( _("(level %d passed)\n"), trust_lvl + 1);
 			break;
+		} else {
+			if (ret < 0)
+				log_err( _("(level %d failed: %s)\n"),
+					 trust_lvl + 1, fail_desc[trust_lvl]);
+			else
+				log_err( _("(level %d failed at block %lld "
+					   "(0x%llx): %s)\n"), trust_lvl + 1,
+					 (unsigned long long)ret,
+					 (unsigned long long)ret,
+					 fail_desc[trust_lvl]);
 		}
-		else
-			log_err( _("(level %d failed: %s)\n"), trust_lvl + 1,
-				 fail_desc[trust_lvl]);
 		if (fsck_abort)
 			break;
 	}
diff --git a/gfs2/fsck/metawalk.c b/gfs2/fsck/metawalk.c
index af27432..92973ae 100644
--- a/gfs2/fsck/metawalk.c
+++ b/gfs2/fsck/metawalk.c
@@ -336,7 +336,7 @@ static int check_entries(struct gfs2_inode *ip, struct gfs2_buffer_head *bh,
 		    de.de_name_len ||
 		    (de.de_inum.no_formal_ino && !de.de_name_len && !first)) {
 			log_err( _("Directory block %llu (0x%llx"
-				"), entry %d of directory %llu"
+				"), entry %d of directory %llu "
 				"(0x%llx) is corrupt.\n"),
 				(unsigned long long)bh->b_blocknr,
 				(unsigned long long)bh->b_blocknr,
diff --git a/gfs2/fsck/pass1.c b/gfs2/fsck/pass1.c
index a1f4232..7077272 100644
--- a/gfs2/fsck/pass1.c
+++ b/gfs2/fsck/pass1.c
@@ -1213,6 +1213,10 @@ static int handle_ip(struct gfs2_sbd *sdp, struct gfs2_inode *ip)
 		   words, we would introduce file system corruption. So we
 		   need to keep track of the fact that it's invalid and
 		   skip parts that we can't be sure of based on dinode type. */
+		log_debug("Invalid mode dinode found at block %lld (0x%llx): "
+			  "Invalidating all its metadata.\n",
+			  (unsigned long long)ip->i_di.di_num.no_addr,
+			  (unsigned long long)ip->i_di.di_num.no_addr);
 		check_metatree(ip, &invalidate_fxns);
 		if (fsck_blockmap_set(ip, block, _("invalid mode"),
 				      gfs2_inode_invalid))
diff --git a/gfs2/fsck/pass1b.c b/gfs2/fsck/pass1b.c
index 65e6de9..259eb7a 100644
--- a/gfs2/fsck/pass1b.c
+++ b/gfs2/fsck/pass1b.c
@@ -426,7 +426,7 @@ static int clear_a_reference(struct gfs2_sbd *sdp, struct duptree *b,
 			log_warn( _("The bad inode was not cleared...\n"));
 			continue;
 		}
-		log_warn( _("Clearing inode %lld (0x%llx)....\n"),
+		log_warn( _("Clearing inode %lld (0x%llx)...\n"),
 			  (unsigned long long)id->block_no,
 			  (unsigned long long)id->block_no);
 		clear_dup_fxns.private = (void *) dh;
@@ -597,7 +597,8 @@ static int handle_dup_blk(struct gfs2_sbd *sdp, struct duptree *b)
 					  gfs2_meta_eattr);
 		fsck_inode_put(&ip); /* out, brelse, free */
 	} else {
-		log_debug( _("All duplicate references were resolved.\n"));
+		/* They may have answered no and not fixed all references. */
+		log_debug( _("All duplicate references were processed.\n"));
 	}
 	return 0;
 }
diff --git a/gfs2/fsck/pass2.c b/gfs2/fsck/pass2.c
index abb77c3..0424241 100644
--- a/gfs2/fsck/pass2.c
+++ b/gfs2/fsck/pass2.c
@@ -258,7 +258,10 @@ static int check_dentry(struct gfs2_inode *ip, struct gfs2_dirent *dent,
 		/* This entry's inode has bad blocks in it */
 
 		/* Handle bad blocks */
-		log_err( _("Found a bad directory entry: %s\n"), tmp_name);
+		log_err( _("Found directory entry '%s' pointing to invalid "
+			   "block %lld (0x%llx)\n"), tmp_name,
+			 (unsigned long long)entryblock,
+			 (unsigned long long)entryblock);
 
 		if (!query( _("Delete inode containing bad blocks? (y/n)"))) {
 			log_warn( _("Entry to inode containing bad blocks remains\n"));
@@ -275,6 +278,9 @@ static int check_dentry(struct gfs2_inode *ip, struct gfs2_dirent *dent,
 			fsck_inode_put(&entry_ip);
 		fsck_blockmap_set(ip, entryblock,
 				  _("bad directory entry"), gfs2_block_free);
+		log_err( _("Inode %lld (0x%llx) was deleted.\n"),
+			 (unsigned long long)entryblock,
+			 (unsigned long long)entryblock);
 		goto nuke_dentry;
 	}
 	if (q < gfs2_inode_dir || q > gfs2_inode_sock) {
@@ -350,7 +356,9 @@ static int check_dentry(struct gfs2_inode *ip, struct gfs2_dirent *dent,
 	}
 
 	if (!strcmp(".", tmp_name)) {
-		log_debug( _("Found . dentry\n"));
+		log_debug( _("Found . dentry in directory %lld (0x%llx)\n"),
+			     (unsigned long long)ip->i_di.di_num.no_addr,
+			     (unsigned long long)ip->i_di.di_num.no_addr);
 
 		if (ds->dotdir) {
 			log_err( _("Already found '.' entry in directory %llu"
@@ -408,9 +416,11 @@ static int check_dentry(struct gfs2_inode *ip, struct gfs2_dirent *dent,
 		goto dentry_is_valid;
 	}
 	if (!strcmp("..", tmp_name)) {
-		log_debug( _("Found .. dentry\n"));
+		log_debug( _("Found '..' dentry in directory %lld (0x%llx)\n"),
+			     (unsigned long long)ip->i_di.di_num.no_addr,
+			     (unsigned long long)ip->i_di.di_num.no_addr);
 		if (ds->dotdotdir) {
-			log_err( _("Already found '..' entry in directory %llu"
+			log_err( _("Already had a '..' entry in directory %llu"
 				"(0x%llx)\n"),
 				(unsigned long long)ip->i_di.di_num.no_addr,
 				(unsigned long long)ip->i_di.di_num.no_addr);
diff --git a/gfs2/fsck/pass5.c b/gfs2/fsck/pass5.c
index 028515b..b71b2b6 100644
--- a/gfs2/fsck/pass5.c
+++ b/gfs2/fsck/pass5.c
@@ -83,7 +83,8 @@ static int check_block_status(struct gfs2_sbd *sdp, char *buffer, unsigned int b
 				   "(0x%llx).\n"),
 				 (unsigned long long)block,
 				 (unsigned long long)block);
-			if (query(_("Do you want to fix the bitmap? (y/n) "))) {
+			if (query(_("Do you want to reclaim the block? "
+				   "(y/n) "))) {
 				if (gfs2_set_bitmap(sdp, block, block_status))
 					log_err(_("Unlinked block %llu "
 						  "(0x%llx) bitmap not fixed."
@@ -104,11 +105,12 @@ static int check_block_status(struct gfs2_sbd *sdp, char *buffer, unsigned int b
 			const char *blockstatus[] = {"Free", "Data",
 						     "Unlinked", "inode"};
 
-			log_err( _("Ondisk and fsck bitmaps differ at"
-					" block %"PRIu64" (0x%" PRIx64 ") \n"), block, block);
-			log_err( _("Ondisk status is %u (%s) but FSCK thinks it should be "),
-					rg_status, blockstatus[rg_status]);
-			log_err("%u (%s)\n", block_status, blockstatus[block_status]);
+			log_err( _("Block %llu (0x%llx) bitmap says %u (%s) "
+				   "but FSCK saw %u (%s)\n"),
+				 (unsigned long long)block,
+				 (unsigned long long)block, rg_status,
+				 blockstatus[rg_status], block_status,
+				 blockstatus[block_status]);
 			if (q) /* Don't print redundant "free" */
 				log_err( _("Metadata type is %u (%s)\n"), q,
 					 block_type_string(q));
@@ -164,8 +166,11 @@ static void update_rgrp(struct gfs2_sbd *sdp, struct rgrp_list *rgp,
 		update = 1;
 	}
 	if (rgp->rg.rg_dinodes != count[1]) {
-		log_err( _("Inode count inconsistent: is %u should be %u\n"),
-				rgp->rg.rg_dinodes, count[1]);
+		log_err( _("RG #%llu (0x%llx) Inode count inconsistent: is "
+			   "%u should be %u\n"),
+			 (unsigned long long)rgp->ri.ri_addr,
+			 (unsigned long long)rgp->ri.ri_addr,
+			 rgp->rg.rg_dinodes, count[1]);
 		rgp->rg.rg_dinodes = count[1];
 		update = 1;
 	}
diff --git a/gfs2/fsck/util.c b/gfs2/fsck/util.c
index b71fc98..9930624 100644
--- a/gfs2/fsck/util.c
+++ b/gfs2/fsck/util.c
@@ -286,7 +286,8 @@ int add_duplicate_ref(struct gfs2_inode *ip, uint64_t block,
 	if (first)
 		log_info( _("This is the original reference.\n"));
 	else
-		log_info( _("This brings the total to: %d\n"), dt->refs);
+		log_info( _("This brings the total to: %d duplicate "
+			    "references\n"), dt->refs);
 	return 0;
 }
 
