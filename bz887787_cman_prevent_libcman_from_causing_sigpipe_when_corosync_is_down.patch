commit 7f67d0a871e5bbafcd98ceb381deb2539f4b0e93
Author: Christine Caulfield <ccaulfie@redhat.com>
Date:   Thu Dec 20 08:49:56 2012 +0000

    cman: prevent libcman from causing SIGPIPE when corosync is down
    
    If corosync goes down/is shut down cman will return 0 from cman_dispatch and
    close the socket. However, if a cman write operation is issued before this
    happens then SIGPIPE can result from the writev() call to an open, but
    disconnected, FD.
    
    This patch changes writev() to sendmg() so it can pass MSG_NOSIGNAL to the
    system call and prevent SIGPIPEs from occurring.
    
    Resolves rhbz#887787
    
    Acked-By: Fabio M. Di Nitto <fdinitto@redhat.com>
    Signed-off-by: Christine Caulfield <ccaulfie@redhat.com>

diff --git a/cman/lib/libcman.c b/cman/lib/libcman.c
index a89c731..a99f5a0 100644
--- a/cman/lib/libcman.c
+++ b/cman/lib/libcman.c
@@ -204,10 +204,19 @@ static int loopy_writev(int fd, struct iovec *iovptr, size_t iovlen)
 {
 	size_t byte_cnt=0;
 	int len;
+	struct msghdr msg;
+
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
 
 	while (iovlen > 0)
 	{
-		len = writev(fd, iovptr, iovlen);
+	  msg.msg_iov = iovptr;
+	  msg.msg_iovlen = iovlen;
+
+	  len = sendmsg(fd, &msg, MSG_NOSIGNAL);
 		if (len <= 0)
 			return len;
 
