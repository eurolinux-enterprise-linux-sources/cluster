commit 972afbfa3d72de2beae350d1c7befffa4a698c55
Author: John Ruemker <jruemker@redhat.com>
Date:   Wed Feb 15 18:37:01 2012 -0500

    cman: Improve quorum timer handling how quorum timers work
    
    Previously, the timer was simply once per quorumd poll interval.
    
    This led to a possibility of qdiskd (or other programs using the
    CMAN quorum API) to continue as 'alive' until a time period greater
    than the poll interval.
    
    With this patch, the quorum device timer is reset each time the
    program using the quorum API.
    
    Resolves: rhbz#759603
    
    Signed-off-by: John Ruemker <jruemker@redhat.com>
    Reviewed-by: Lon Hohberger <lhh@redhat.com>
    Reviewed-by: Christine Caulfield <ccaulfie@redhat.com>

diff --git a/cman/daemon/commands.c b/cman/daemon/commands.c
index 98dee3b..83a2f4a 100644
--- a/cman/daemon/commands.c
+++ b/cman/daemon/commands.c
@@ -1334,19 +1334,21 @@ static void ccsd_timer_fn(void *arg)
 static void quorum_device_timer_fn(void *arg)
 {
 	struct timeval now;
+	unsigned long long timediff_us;
 	if (!quorum_device || quorum_device->state == NODESTATE_DEAD)
 		return;
 
 	log_printf(LOGSYS_LEVEL_DEBUG, "memb: quorum_device_timer_fn\n");
 	gettimeofday(&now, NULL);
-	if (quorum_device->last_hello.tv_sec + quorumdev_poll/1000 < now.tv_sec) {
+	timediff_us=((now.tv_sec - quorum_device->last_hello.tv_sec)*1000000 + (now.tv_usec - quorum_device->last_hello.tv_usec));
+	if (timediff_us >= quorumdev_poll*1000) {
 		quorum_device->state = NODESTATE_DEAD;
 		log_printf(LOG_INFO, "lost contact with quorum device\n");
 		recalculate_quorum(0, 0);
 	}
 	else {
-		corosync->timer_add_duration((unsigned long long)quorumdev_poll*1000000, quorum_device,
-					   quorum_device_timer_fn, &quorum_device_timer);
+		corosync->timer_add_duration(1000*(quorumdev_poll*1000 - timediff_us),
+			quorum_device, quorum_device_timer_fn, &quorum_device_timer); 	
 	}
 }
 
