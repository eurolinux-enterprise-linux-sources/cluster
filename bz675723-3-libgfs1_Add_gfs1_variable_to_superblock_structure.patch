commit fd26766e1142d90d86d4b3280acf3cbc6c50086e
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Aug 8 09:45:36 2011 -0500

    libgfs1: Add gfs1 variable to superblock structure
    
    This patch adds a "gfs1" variable to the in-core superblock structure
    for utils that can operate on both gfs and gfs2 file systems and need
    to determine which is which.
    
    rhbz#675723

diff --git a/gfs2/edit/extended.c b/gfs2/edit/extended.c
index 3c45060..059f18b 100644
--- a/gfs2/edit/extended.c
+++ b/gfs2/edit/extended.c
@@ -64,7 +64,7 @@ static int _do_indirect_extended(char *diebuf, struct iinfo *iinf, int hgt)
 		iinf->ii[x].dirents = 0;
 		memset(&iinf->ii[x].dirent, 0, sizeof(struct gfs2_dirents));
 	}
-	for (x = (gfs1 ? sizeof(struct gfs_indirect):
+	for (x = (sbd.gfs1 ? sizeof(struct gfs_indirect):
 			  sizeof(struct gfs2_meta_header)), y = 0;
 		 x < sbd.bsize;
 		 x += sizeof(uint64_t), y++) {
@@ -250,7 +250,7 @@ static int display_indirect(struct iinfo *ind, int indblocks, int level,
 /* ------------------------------------------------------------------------ */
 static void print_inode_type(__be16 de_type)
 {
-	if (gfs1) {
+	if (sbd.gfs1) {
 		switch(de_type) {
 		case GFS_FILE_NON:
 			print_gfs2("Unknown");
@@ -514,7 +514,7 @@ static int parse_rindex(struct gfs2_inode *dip, int print_rindex)
 
 		roff = print_entry_ndx * risize();
 
-		if (gfs1)
+		if (sbd.gfs1)
 			error = gfs1_readi(dip, (void *)&rbuf, roff, risize());
 		else
 			error = gfs2_readi(dip, (void *)&rbuf, roff, risize());
@@ -542,7 +542,7 @@ static int parse_rindex(struct gfs2_inode *dip, int print_rindex)
 				struct gfs2_buffer_head *tmp_bh;
 
 				tmp_bh = bread(&sbd, ri.ri_addr);
-				if (gfs1) {
+				if (sbd.gfs1) {
 					struct gfs_rgrp rg1;
 					gfs_rgrp_in(&rg1, tmp_bh);
 					gfs_rgrp_print(&rg1);
@@ -663,7 +663,7 @@ int display_extended(void)
 	else if (display_indirect(indirect, indirect_blocks, 0, 0) == 0)
 		return -1;
 	else if (block_is_rglist()) {
-		if (gfs1)
+		if (sbd.gfs1)
 			tmp_bh = bread(&sbd, sbd1->sb_rindex_di.no_addr);
 		else
 			tmp_bh = bread(&sbd, masterblock("rindex"));
diff --git a/gfs2/edit/gfs2hex.c b/gfs2/edit/gfs2hex.c
index 0f8a84a5..7962228 100644
--- a/gfs2/edit/gfs2hex.c
+++ b/gfs2/edit/gfs2hex.c
@@ -43,7 +43,6 @@ uint64_t block = 0;
 int blockhist = 0;
 struct iinfo *indirect;
 int indirect_blocks;
-int gfs1  = 0;
 uint64_t block_in_mem = -1;
 struct gfs2_sbd sbd;
 uint64_t starting_blk;
@@ -275,7 +274,7 @@ void do_dinode_extended(struct gfs2_dinode *dine, struct gfs2_buffer_head *lbh)
 	unsigned int x, y, ptroff = 0;
 	uint64_t p, last;
 	int isdir = !!(S_ISDIR(dine->di_mode)) || 
-		(gfs1 && dine->__pad1 == GFS_FILE_DIR);
+		(sbd.gfs1 && dine->__pad1 == GFS_FILE_DIR);
 
 	indirect_blocks = 0;
 	memset(indirect, 0, sizeof(indirect));
@@ -466,11 +465,11 @@ static void gfs2_sb_print2(struct gfs2_sb *sbp2)
 	pv(sbp2, sb_fs_format, "%u", "0x%x");
 	pv(sbp2, sb_multihost_format, "%u", "0x%x");
 
-	if (gfs1)
+	if (sbd.gfs1)
 		pv(sbd1, sb_flags, "%u", "0x%x");
 	pv(sbp2, sb_bsize, "%u", "0x%x");
 	pv(sbp2, sb_bsize_shift, "%u", "0x%x");
-	if (gfs1) {
+	if (sbd.gfs1) {
 		pv(sbd1, sb_seg_size, "%u", "0x%x");
 		gfs2_inum_print2("jindex ino", &sbd1->sb_jindex_di);
 		gfs2_inum_print2("rindex ino", &sbd1->sb_rindex_di);
@@ -481,7 +480,7 @@ static void gfs2_sb_print2(struct gfs2_sb *sbp2)
 
 	pv(sbp2, sb_lockproto, "%s", NULL);
 	pv(sbp2, sb_locktable, "%s", NULL);
-	if (gfs1) {
+	if (sbd.gfs1) {
 		gfs2_inum_print2("quota ino ", &gfs1_quota_di);
 		gfs2_inum_print2("license   ", &gfs1_license_di);
 	}
@@ -573,7 +572,7 @@ int display_gfs2(void)
 			break;
 
 		case GFS2_METATYPE_RG:
-			if (gfs1) {
+			if (sbd.gfs1) {
 				struct gfs1_rgrp rg1;
 
 				gfs1_rgrp_in(&rg1, bh);
@@ -606,7 +605,7 @@ int display_gfs2(void)
 			break;
 
 		case GFS2_METATYPE_LH:
-			if (gfs1) {
+			if (sbd.gfs1) {
 				gfs_log_header_in(&lh1, bh);
 				gfs_log_header_print(&lh1);
 			} else {
diff --git a/gfs2/edit/hexedit.c b/gfs2/edit/hexedit.c
index d908169..79a297e 100644
--- a/gfs2/edit/hexedit.c
+++ b/gfs2/edit/hexedit.c
@@ -1067,13 +1067,14 @@ int display_block_type(int from_restore)
 		print_gfs2("of %llu (0x%llx) ", max_block, max_block);
 	if (block == RGLIST_DUMMY_BLOCK) {
 		ret_type = GFS2_METATYPE_RG;
-		struct_len = gfs1 ? sizeof(struct gfs_rgrp) : sizeof(struct gfs2_rgrp);
+		struct_len = sbd.gfs1 ? sizeof(struct gfs_rgrp) :
+			sizeof(struct gfs2_rgrp);
 	}
 	else if ((ret_type = get_block_type(bh))) {
 		switch (*(bh->b_data + 7)) {
 		case GFS2_METATYPE_SB:   /* 1 */
 			print_gfs2("(superblock)");
-			if (gfs1)
+			if (sbd.gfs1)
 				struct_len = sizeof(struct gfs_sb);
 			else
 				struct_len = sizeof(struct gfs2_sb);
@@ -1092,7 +1093,7 @@ int display_block_type(int from_restore)
 			break;
 		case GFS2_METATYPE_IN:   /* 5 */
 			print_gfs2("(indir blklist)");
-			if (gfs1)
+			if (sbd.gfs1)
 				struct_len = sizeof(struct gfs_indirect);
 			else
 				struct_len = sizeof(struct gfs2_meta_header);
@@ -1111,7 +1112,7 @@ int display_block_type(int from_restore)
 			break;
 		case GFS2_METATYPE_LD:
 		 	print_gfs2("(log descriptor)");
-			if (gfs1)
+			if (sbd.gfs1)
 				struct_len = sizeof(struct gfs_log_descriptor);
 			else
 				struct_len =
@@ -1166,7 +1167,7 @@ int display_block_type(int from_restore)
 		print_gfs2("(p.%d of %d--%s)", pgnum + 1,
 			   (sbd.bsize % screen_chunk_size) > 0 ?
 			   sbd.bsize / screen_chunk_size + 1 : sbd.bsize /
-			   screen_chunk_size, allocdesc[gfs1][type]);
+			   screen_chunk_size, allocdesc[sbd.gfs1][type]);
 		/*eol(9);*/
 		if ((*(bh->b_data + 7) == GFS2_METATYPE_RG)) {
 			int ptroffset = edit_row[dmode] * 16 + edit_col[dmode];
@@ -1183,7 +1184,7 @@ int display_block_type(int from_restore)
 				for (b = blknum; b < blknum + 4; b++) {
 					btype = gfs2_get_bitmap(&sbd, b, rgd);
 					print_gfs2("0x%x-%s  ", b,
-						   allocdesc[gfs1][btype]);
+						   allocdesc[sbd.gfs1][btype]);
 				}
 			}
 		} else if ((*(bh->b_data + 7) == GFS2_METATYPE_RB)) {
@@ -1215,7 +1216,7 @@ int display_block_type(int from_restore)
 				for (b = blknum; b < blknum + 4; b++) {
 					btype = gfs2_get_bitmap(&sbd, b, rgd);
 					print_gfs2("0x%x-%s  ", b,
-						   allocdesc[gfs1][btype]);
+						   allocdesc[sbd.gfs1][btype]);
 				}
 			}
 		}
@@ -1224,12 +1225,12 @@ int display_block_type(int from_restore)
  	}
 	if (block == sbd.sd_sb.sb_root_dir.no_addr)
 		print_gfs2("--------------- Root directory ------------------");
-	else if (!gfs1 && block == sbd.sd_sb.sb_master_dir.no_addr)
+	else if (!sbd.gfs1 && block == sbd.sd_sb.sb_master_dir.no_addr)
 		print_gfs2("-------------- Master directory -----------------");
-	else if (!gfs1 && block == RGLIST_DUMMY_BLOCK)
+	else if (!sbd.gfs1 && block == RGLIST_DUMMY_BLOCK)
 		print_gfs2("------------------ RG List ----------------------");
 	else {
-		if (gfs1) {
+		if (sbd.gfs1) {
 			if (block == sbd1->sb_rindex_di.no_addr)
 				print_gfs2("---------------- rindex file -------------------");
 			else if (block == gfs1_quota_di.no_addr)
@@ -1435,7 +1436,7 @@ static int hexdump(uint64_t startaddr, int len)
 		l+=16;
 		print_entry_ndx++;
 	} /* while */
-	if (gfs1) {
+	if (sbd.gfs1) {
 		COLORS_NORMAL;
 		print_gfs2("         *** This seems to be a GFS-1 file system ***");
 		eol(0);
@@ -1479,7 +1480,7 @@ static uint64_t find_rgrp_block(struct gfs2_inode *dif, int rg)
 	uint64_t foffset, gfs1_adj = 0;
 
 	foffset = rg * risize();
-	if (gfs1) {
+	if (sbd.gfs1) {
 		uint64_t sd_jbsize =
 			(sbd.bsize - sizeof(struct gfs2_meta_header));
 
@@ -1551,7 +1552,7 @@ static uint64_t get_rg_addr(int rgnum)
 	uint64_t rgblk = 0, gblock;
 	struct gfs2_inode *riinode;
 
-	if (gfs1)
+	if (sbd.gfs1)
 		gblock = sbd1->sb_rindex_di.no_addr;
 	else
 		gblock = masterblock("rindex");
@@ -1583,7 +1584,7 @@ static void set_rgrp_flags(int rgnum, uint32_t new_flags, int modify, int full)
 
 	rgblk = get_rg_addr(rgnum);
 	rbh = bread(&sbd, rgblk);
-	if (gfs1)
+	if (sbd.gfs1)
 		gfs_rgrp_in(&rg.rg1, rbh);
 	else
 		gfs2_rgrp_in(&rg.rg2, rbh);
@@ -1592,7 +1593,7 @@ static void set_rgrp_flags(int rgnum, uint32_t new_flags, int modify, int full)
 		       rgnum, (unsigned long long)rgblk,
 		       (unsigned long long)rgblk, rg.rg2.rg_flags, new_flags);
 		rg.rg2.rg_flags = new_flags;
-		if (gfs1)
+		if (sbd.gfs1)
 			gfs_rgrp_out(&rg.rg1, rbh);
 		else
 			gfs2_rgrp_out(&rg.rg2, rbh);
@@ -1602,7 +1603,7 @@ static void set_rgrp_flags(int rgnum, uint32_t new_flags, int modify, int full)
 			print_gfs2("RG #%d", rgnum);
 			print_gfs2(" located at: %llu (0x%llx)", rgblk, rgblk);
                         eol(0);
-			if (gfs1)
+			if (sbd.gfs1)
 				gfs_rgrp_print(&rg.rg1);
 			else
 				gfs2_rgrp_print(&rg.rg2);
@@ -1638,7 +1639,7 @@ int has_indirect_blocks(void)
 	if (indirect_blocks || gfs2_struct_type == GFS2_METATYPE_SB ||
 	    gfs2_struct_type == GFS2_METATYPE_LF ||
 	    (gfs2_struct_type == GFS2_METATYPE_DI &&
-	     (S_ISDIR(di.di_mode) || (gfs1 && di.__pad1 == GFS_FILE_DIR))))
+	     (S_ISDIR(di.di_mode) || (sbd.gfs1 && di.__pad1 == GFS_FILE_DIR))))
 		return TRUE;
 	return FALSE;
 }
@@ -1648,7 +1649,7 @@ int has_indirect_blocks(void)
 /* ------------------------------------------------------------------------ */
 int block_is_rindex(void)
 {
-	if ((gfs1 && block == sbd1->sb_rindex_di.no_addr) ||
+	if ((sbd.gfs1 && block == sbd1->sb_rindex_di.no_addr) ||
 	    (block == masterblock("rindex")))
 		return TRUE;
 	return FALSE;
@@ -1659,7 +1660,7 @@ int block_is_rindex(void)
 /* ------------------------------------------------------------------------ */
 int block_is_jindex(void)
 {
-	if ((gfs1 && block == sbd1->sb_jindex_di.no_addr))
+	if ((sbd.gfs1 && block == sbd1->sb_jindex_di.no_addr))
 		return TRUE;
 	return FALSE;
 }
@@ -1669,7 +1670,7 @@ int block_is_jindex(void)
 /* ------------------------------------------------------------------------ */
 int block_is_inum_file(void)
 {
-	if (!gfs1 && block == masterblock("inum"))
+	if (!sbd.gfs1 && block == masterblock("inum"))
 		return TRUE;
 	return FALSE;
 }
@@ -1679,9 +1680,9 @@ int block_is_inum_file(void)
 /* ------------------------------------------------------------------------ */
 int block_is_statfs_file(void)
 {
-	if (gfs1 && block == gfs1_license_di.no_addr)
+	if (sbd.gfs1 && block == gfs1_license_di.no_addr)
 		return TRUE;
-	if (!gfs1 && block == masterblock("statfs"))
+	if (!sbd.gfs1 && block == masterblock("statfs"))
 		return TRUE;
 	return FALSE;
 }
@@ -1691,9 +1692,9 @@ int block_is_statfs_file(void)
 /* ------------------------------------------------------------------------ */
 int block_is_quota_file(void)
 {
-	if (gfs1 && block == gfs1_quota_di.no_addr)
+	if (sbd.gfs1 && block == gfs1_quota_di.no_addr)
 		return TRUE;
-	if (!gfs1 && block == masterblock("quota"))
+	if (!sbd.gfs1 && block == masterblock("quota"))
 		return TRUE;
 	return FALSE;
 }
@@ -1703,7 +1704,7 @@ int block_is_quota_file(void)
 /* ------------------------------------------------------------------------ */
 int block_is_per_node(void)
 {
-	if (!gfs1 && block == masterblock("per_node"))
+	if (!sbd.gfs1 && block == masterblock("per_node"))
 		return TRUE;
 	return FALSE;
 }
@@ -1716,7 +1717,7 @@ int block_is_in_per_node(void)
 	int d;
 	struct gfs2_inode *per_node_di;
 
-	if (gfs1)
+	if (sbd.gfs1)
 		return FALSE;
 
 	per_node_di = inode_read(&sbd, masterblock("per_node"));
@@ -1774,7 +1775,7 @@ static void read_superblock(int fd)
 		sbd1->sb_multihost_format == GFS_FORMAT_MULTI) {
 		struct gfs_sb *sbbuf = (struct gfs_sb *)bh->b_data;
 
-		gfs1 = TRUE;
+		sbd.gfs1 = TRUE;
 		sbd1->sb_flags = be32_to_cpu(sbbuf->sb_flags);
 		sbd1->sb_seg_size = be32_to_cpu(sbbuf->sb_seg_size);
 		gfs2_inum_in(&sbd1->sb_rindex_di, (void *)&sbbuf->sb_rindex_di);
@@ -1782,12 +1783,12 @@ static void read_superblock(int fd)
 		gfs2_inum_in(&gfs1_license_di, (void *)&sbbuf->sb_license_di);
 	}
 	else
-		gfs1 = FALSE;
+		sbd.gfs1 = FALSE;
 	sbd.bsize = sbd.sd_sb.sb_bsize;
 	if (!sbd.bsize)
 		sbd.bsize = GFS2_DEFAULT_BSIZE;
 	compute_constants(&sbd);
-	if (gfs1 || (sbd.sd_sb.sb_header.mh_magic == GFS2_MAGIC &&
+	if (sbd.gfs1 || (sbd.sd_sb.sb_header.mh_magic == GFS2_MAGIC &&
 		     sbd.sd_sb.sb_header.mh_type == GFS2_METATYPE_SB))
 		block = 0x10 * (GFS2_DEFAULT_BSIZE / sbd.bsize);
 	else {
@@ -1799,7 +1800,7 @@ static void read_superblock(int fd)
 				sbd.device.length << GFS2_BASIC_BLOCK_SHIFT);
 		exit(-1);
 	}
-	if(gfs1) {
+	if(sbd.gfs1) {
 		sbd.sd_inptrs = (sbd.bsize - sizeof(struct gfs_indirect)) /
 			sizeof(uint64_t);
 		sbd.sd_diptrs = (sbd.bsize - sizeof(struct gfs_dinode)) /
@@ -1854,7 +1855,7 @@ int display(int identify_only)
 	uint64_t blk;
 
 	if (block == RGLIST_DUMMY_BLOCK) {
-		if (gfs1)
+		if (sbd.gfs1)
 			blk = sbd1->sb_rindex_di.no_addr;
 		else
 			blk = masterblock("rindex");
@@ -2014,7 +2015,7 @@ static uint64_t find_journal_block(const char *journal, uint64_t *j_size)
 
 	journal_num = atoi(journal + 7);
 	/* Figure out the block of the jindex file */
-	if (gfs1)
+	if (sbd.gfs1)
 		jindex_block = sbd1->sb_jindex_di.no_addr;
 	else
 		jindex_block = masterblock("jindex");
@@ -2023,10 +2024,10 @@ static uint64_t find_journal_block(const char *journal, uint64_t *j_size)
 	/* get the dinode data from it. */
 	gfs2_dinode_in(&di, jindex_bh); /* parse disk inode to struct*/
 
-	if (!gfs1)
+	if (!sbd.gfs1)
 		do_dinode_extended(&di, jindex_bh); /* parse dir. */
 
-	if (gfs1) {
+	if (sbd.gfs1) {
 		struct gfs2_inode *jiinode;
 		struct gfs_jindex ji;
 
@@ -2205,36 +2206,36 @@ uint64_t check_keywords(const char *kword)
 	else if (!strcmp(kword, "root") || !strcmp(kword, "rootdir"))
 		blk = sbd.sd_sb.sb_root_dir.no_addr;
 	else if (!strcmp(kword, "master")) {
-		if (!gfs1)
+		if (!sbd.gfs1)
 			blk = sbd.sd_sb.sb_master_dir.no_addr;
 		else
 			fprintf(stderr, "This is GFS1; there's no master directory.\n");
 	}
 	else if (!strcmp(kword, "jindex")) {
-		if (gfs1)
+		if (sbd.gfs1)
 			blk = sbd1->sb_jindex_di.no_addr;
 		else
 			blk = masterblock("jindex"); /* journal index */
 	}
-	else if (!gfs1 && !strcmp(kword, "per_node"))
+	else if (!sbd.gfs1 && !strcmp(kword, "per_node"))
 		blk = masterblock("per_node");
-	else if (!gfs1 && !strcmp(kword, "inum"))
+	else if (!sbd.gfs1 && !strcmp(kword, "inum"))
 		blk = masterblock("inum");
 	else if (!strcmp(kword, "statfs")) {
-		if (gfs1)
+		if (sbd.gfs1)
 			blk = gfs1_license_di.no_addr;
 		else
 			blk = masterblock("statfs");
 	}
 	else if (!strcmp(kword, "rindex") || !strcmp(kword, "rgindex")) {
-		if (gfs1)
+		if (sbd.gfs1)
 			blk = sbd1->sb_rindex_di.no_addr;
 		else
 			blk = masterblock("rindex");
 	} else if (!strcmp(kword, "rgs")) {
 		blk = RGLIST_DUMMY_BLOCK;
 	} else if (!strcmp(kword, "quota")) {
-		if (gfs1)
+		if (sbd.gfs1)
 			blk = gfs1_quota_di.no_addr;
 		else
 			blk = masterblock("quota");
@@ -2550,7 +2551,7 @@ static void find_change_block_alloc(int *newval)
 		printf("Error: value %d is not valid.\nValid values are:\n",
 		       *newval);
 		for (i = GFS2_BLKST_FREE; i <= GFS2_BLKST_DINODE; i++)
-			printf("%d - %s\n", i, allocdesc[gfs1][i]);
+			printf("%d - %s\n", i, allocdesc[sbd.gfs1][i]);
 		gfs2_rgrp_free(&sbd.rglist);
 		exit(-1);
 	}
@@ -2573,7 +2574,7 @@ static void find_change_block_alloc(int *newval)
 					       "an rgrp).\n");
 					exit(-1);
 				}
-				printf("%d (%s)\n", type, allocdesc[gfs1][type]);
+				printf("%d (%s)\n", type, allocdesc[sbd.gfs1][type]);
 			}
 			gfs2_rgrp_relse(rgd);
 		} else {
@@ -3057,7 +3058,7 @@ static int print_ld_blocks(const uint64_t *b, const char *end, int start_line)
 			bcount++;
 		}
 		b++;
-		if (gfs1)
+		if (sbd.gfs1)
 			b++;
 	}
 	eol(0);
@@ -3176,14 +3177,14 @@ static void dump_journal(const char *journal)
 	jblock = find_journal_block(journal, &j_size);
 	if (!jblock)
 		return;
-	if (!gfs1) {
+	if (!sbd.gfs1) {
 		j_bh = bread(&sbd, jblock);
 		j_inode = inode_get(&sbd, j_bh);
 		jbuf = malloc(sbd.bsize);
 	}
 
-	for (jb = 0; jb < j_size; jb += (gfs1 ? 1:sbd.bsize)) {
-		if (gfs1) {
+	for (jb = 0; jb < j_size; jb += (sbd.gfs1 ? 1:sbd.bsize)) {
+		if (sbd.gfs1) {
 			if (j_bh)
 				brelse(j_bh);
 			j_bh = bread(&sbd, jblock + jb);
@@ -3218,21 +3219,21 @@ static void dump_journal(const char *journal)
 				 "Quota", "Final Entry", "Unknown"}};
 
 			print_gfs2("0x%llx (j+%4llx): Log descriptor, ",
-				   abs_block, jb / (gfs1 ? 1 : sbd.bsize));
+				   abs_block, jb / (sbd.gfs1 ? 1 : sbd.bsize));
 			gfs2_log_descriptor_in(&ld, &dummy_bh);
 			print_gfs2("type %d ", ld.ld_type);
 
 			for (ltndx = 0;; ltndx++) {
-				if (ld.ld_type == logtypes[gfs1][ltndx] ||
-				    logtypes[gfs1][ltndx] == 0)
+				if (ld.ld_type == logtypes[sbd.gfs1][ltndx] ||
+				    logtypes[sbd.gfs1][ltndx] == 0)
 					break;
 			}
-			print_gfs2("(%s) ", logtypestr[gfs1][ltndx]);
+			print_gfs2("(%s) ", logtypestr[sbd.gfs1][ltndx]);
 			print_gfs2("len:%u, data1: %u",
 				   ld.ld_length, ld.ld_data1);
 			eol(0);
 			print_gfs2("                    ");
-			if (gfs1)
+			if (sbd.gfs1)
 				b = (uint64_t *)(dummy_bh.b_data +
 					sizeof(struct gfs_log_descriptor));
 			else
@@ -3246,7 +3247,7 @@ static void dump_journal(const char *journal)
 			struct gfs2_log_header lh;
 			struct gfs_log_header lh1;
 
-			if (gfs1) {
+			if (sbd.gfs1) {
 				gfs_log_header_in(&lh1, &dummy_bh);
 				check_journal_wrap(lh1.lh_sequence,
 						   &highest_seq);
@@ -3268,7 +3269,7 @@ static void dump_journal(const char *journal)
 					   lh.lh_tail, lh.lh_blkno);
 			}
 			eol(0);
-		} else if (gfs1 && ld_blocks > 0) {
+		} else if (sbd.gfs1 && ld_blocks > 0) {
 			print_gfs2("0x%llx (j+%4llx): GFS log descriptor"
 				   " continuation block", abs_block, jb);
 			eol(0);
@@ -3658,7 +3659,7 @@ int main(int argc, char *argv[])
 	read_superblock(fd);
 	max_block = lseek(fd, 0, SEEK_END) / sbd.bsize;
 	strcpy(sbd.device_name, device);
-	if (gfs1)
+	if (sbd.gfs1)
 		edit_row[GFS2_MODE]++;
 	else
 		read_master_dir();
diff --git a/gfs2/edit/hexedit.h b/gfs2/edit/hexedit.h
index cc87925..8a3c615 100644
--- a/gfs2/edit/hexedit.h
+++ b/gfs2/edit/hexedit.h
@@ -81,7 +81,6 @@ extern char device[NAME_MAX];
 extern int identify;
 extern int color_scheme;
 extern WINDOW *wind;
-extern int gfs1;
 extern int editing;
 extern uint64_t temp_blk;
 extern uint64_t starting_blk;
@@ -231,7 +230,7 @@ extern enum dsp_mode dmode;
 /* ------------------------------------------------------------------------ */
 static inline int risize(void)
 {
-	if (gfs1)
+	if (sbd.gfs1)
 		return sizeof(struct gfs_rindex);
 	else
 		return sizeof(struct gfs2_rindex);
diff --git a/gfs2/edit/savemeta.c b/gfs2/edit/savemeta.c
index 160277c..c4719ea 100644
--- a/gfs2/edit/savemeta.c
+++ b/gfs2/edit/savemeta.c
@@ -120,12 +120,12 @@ static int get_gfs_struct_info(struct gfs2_buffer_head *lbh, int *block_type,
 		*gstruct_len = sbd.bsize;
 		break;
 	case GFS2_METATYPE_DI:   /* 4 (disk inode) */
-		if (gfs1)
+		if (sbd.gfs1)
 			inode = inode_get(&sbd, lbh);
 		else
 			inode = gfs_inode_get(&sbd, lbh);
 		if (S_ISDIR(inode->i_di.di_mode) ||
-		     (gfs1 && inode->i_di.__pad1 == GFS_FILE_DIR))
+		     (sbd.gfs1 && inode->i_di.__pad1 == GFS_FILE_DIR))
 			*gstruct_len = sbd.bsize;
 		else if (!inode->i_di.di_height && !block_is_systemfile() &&
 			 !S_ISDIR(inode->i_di.di_mode))
@@ -143,7 +143,7 @@ static int get_gfs_struct_info(struct gfs2_buffer_head *lbh, int *block_type,
 		*gstruct_len = sbd.bsize;
 		break;
 	case GFS2_METATYPE_LH:   /* 8 (log header) */
-		if (gfs1)
+		if (sbd.gfs1)
 			*gstruct_len = 512; /* gfs copies the log header
 					       twice and compares the copy,
 					       so we need to save all 512
@@ -454,7 +454,7 @@ static void save_inode_data(struct metafd *mfd)
 	for (i = 0; i < GFS2_MAX_META_HEIGHT; i++)
 		osi_list_init(&metalist[i]);
 	metabh = bread(&sbd, block);
-	if (gfs1)
+	if (sbd.gfs1)
 		inode = inode_get(&sbd, metabh);
 	else
 		inode = gfs_inode_get(&sbd, metabh);
@@ -466,7 +466,7 @@ static void save_inode_data(struct metafd *mfd)
 	   the hash table exists, and we have to save the directory data. */
 	if (inode->i_di.di_flags & GFS2_DIF_EXHASH &&
 	    (S_ISDIR(inode->i_di.di_mode) ||
-	     (gfs1 && inode->i_di.__pad1 == GFS_FILE_DIR)))
+	     (sbd.gfs1 && inode->i_di.__pad1 == GFS_FILE_DIR)))
 		height++;
 	else if (height && !block_is_systemfile() &&
 		 !S_ISDIR(inode->i_di.di_mode))
@@ -563,7 +563,7 @@ static void get_journal_inode_blocks(void)
 		int amt;
 		struct gfs2_inode *j_inode = NULL;
 
-		if (gfs1) {
+		if (sbd.gfs1) {
 			struct gfs_jindex ji;
 			char jbuf[sizeof(struct gfs_jindex)];
 
@@ -647,7 +647,7 @@ void savemeta(char *out_fn, int saveoption, int gziplevel)
 
 	lseek(sbd.device_fd, 0, SEEK_SET);
 	blks_saved = total_out = last_reported_block = 0;
-	if (!gfs1)
+	if (!sbd.gfs1)
 		sbd.bsize = BUFSIZE;
 	if (!slow) {
 		if (device_geometry(&sbd)) {
@@ -660,13 +660,13 @@ void savemeta(char *out_fn, int saveoption, int gziplevel)
 			exit(-1);
 		}
 		osi_list_init(&sbd.rglist);
-		if (!gfs1)
+		if (!sbd.gfs1)
 			sbd.sd_sb.sb_bsize = GFS2_DEFAULT_BSIZE;
 		if (compute_constants(&sbd)) {
 			fprintf(stderr, "Bad constants (1)\n");
 			exit(-1);
 		}
-		if(gfs1) {
+		if(sbd.gfs1) {
 			sbd.bsize = sbd.sd_sb.sb_bsize;
 			sbd.sd_inptrs = (sbd.bsize -
 					 sizeof(struct gfs_indirect)) /
@@ -691,7 +691,7 @@ void savemeta(char *out_fn, int saveoption, int gziplevel)
 	printf("There are %" PRIu64 " blocks of %u bytes in the destination "
 	       "device.\n", last_fs_block, sbd.bsize);
 	if (!slow) {
-		if (gfs1) {
+		if (sbd.gfs1) {
 			sbd.md.riinode = inode_read(&sbd,
 						sbd1->sb_rindex_di.no_addr);
 			jindex_block = sbd1->sb_jindex_di.no_addr;
@@ -706,7 +706,7 @@ void savemeta(char *out_fn, int saveoption, int gziplevel)
 		}
 		lbh = bread(&sbd, jindex_block);
 		gfs2_dinode_in(&di, lbh);
-		if (!gfs1)
+		if (!sbd.gfs1)
 			do_dinode_extended(&di, lbh);
 		brelse(lbh);
 	}
@@ -716,7 +716,7 @@ void savemeta(char *out_fn, int saveoption, int gziplevel)
 
 		printf("Reading resource groups...");
 		fflush(stdout);
-		if (gfs1)
+		if (sbd.gfs1)
 			slow = gfs1_ri_update(&sbd, 0, &rgcount, 0);
 		else
 			slow = ri_update(&sbd, 0, &rgcount, &sane);
@@ -738,7 +738,7 @@ void savemeta(char *out_fn, int saveoption, int gziplevel)
 		save_block(sbd.device_fd, &mfd, 0x10 * (4096 / sbd.bsize));
 		/* If this is gfs1, save off the rindex because it's not
 		   part of the file system as it is in gfs2. */
-		if (gfs1) {
+		if (sbd.gfs1) {
 			int j;
 
 			block = sbd1->sb_rindex_di.no_addr;
@@ -919,7 +919,7 @@ static int restore_data(int fd, gzFile *gzin_fd, int printblocksonly,
 			    sbd1->sb_header.mh_type == GFS_METATYPE_SB &&
 			    sbd1->sb_header.mh_format == GFS_FORMAT_SB &&
 			    sbd1->sb_multihost_format == GFS_FORMAT_MULTI) {
-				gfs1 = TRUE;
+				sbd.gfs1 = TRUE;
 			} else if (check_sb(&sbd.sd_sb)) {
 				fprintf(stderr,"Error: Invalid superblock data.\n");
 				return -1;
@@ -935,7 +935,7 @@ static int restore_data(int fd, gzFile *gzin_fd, int printblocksonly,
 				       " device.\n\n",
 				       last_fs_block, sbd.bsize);
 			} else {
-				printf("This is %s metadata\n", gfs1 ?
+				printf("This is %s metadata\n", sbd.gfs1 ?
 				       "gfs (not gfs2)" : "gfs2");
 			}
 			first = 0;
diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
index 9063c8b..9c79959 100644
--- a/gfs2/libgfs2/libgfs2.h
+++ b/gfs2/libgfs2/libgfs2.h
@@ -243,6 +243,7 @@ struct gfs2_sbd {
 	uint32_t physical_block_size;
 	uint64_t rg_one_length;
 	uint64_t rg_length;
+	int gfs1;
 };
 
 struct metapath {
