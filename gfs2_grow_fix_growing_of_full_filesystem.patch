commit 95f9f828cc8be8999d7c827b286f650519d92a2e
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Mon May 30 01:27:21 2011 -0500

    gfs2_grow: fix growing of full filesystems
    
    gfs2_grow was unable to grow completely full filesystems if there wasn't
    enough space in the last rindex block for another rindex entry. Now
    mkfs.gfs2 makes sure to allocate enough space for another entry without
    increasing the file size, and gfs2_grow uses the fallocate system call
    to do the same.
    
    Also gfs2_grow was occasionally unable to grow a completely full
    filesystem when the rindex file was stuffed, or the filesystem blocksize
    was smaller than the page size. This is because gfs2 needs to be able to
    write the first page of the rindex data without doing an allocation. Now
    gfs2_grow writes the first rindex entry to grow the filesystem by one
    resource group, and then writes the rest.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>

diff --git a/gfs2/libgfs2/fs_ops.c b/gfs2/libgfs2/fs_ops.c
index 4019894..353d47f 100644
--- a/gfs2/libgfs2/fs_ops.c
+++ b/gfs2/libgfs2/fs_ops.c
@@ -575,8 +575,8 @@ static void copy_from_mem(struct gfs2_buffer_head *bh, void **buf,
 	*p += size;
 }
 
-int gfs2_writei(struct gfs2_inode *ip, void *buf,
-				uint64_t offset, unsigned int size)
+int __gfs2_writei(struct gfs2_inode *ip, void *buf,
+		  uint64_t offset, unsigned int size, int resize)
 {
 	struct gfs2_sbd *sdp = ip->i_sbd;
 	struct gfs2_buffer_head *bh;
@@ -647,7 +647,7 @@ int gfs2_writei(struct gfs2_inode *ip, void *buf,
 		o = (isdir) ? sizeof(struct gfs2_meta_header) : 0;
 	}
 
-	if (ip->i_di.di_size < start + copied) {
+	if (resize && ip->i_di.di_size < start + copied) {
 		bmodified(ip->i_bh);
 		ip->i_di.di_size = start + copied;
 	}
diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
index a2c5704..9e97267 100644
--- a/gfs2/libgfs2/libgfs2.h
+++ b/gfs2/libgfs2/libgfs2.h
@@ -437,8 +437,10 @@ extern uint64_t meta_alloc(struct gfs2_inode *ip);
 extern uint64_t dinode_alloc(struct gfs2_sbd *sdp);
 extern int gfs2_readi(struct gfs2_inode *ip, void *buf, uint64_t offset,
 		      unsigned int size);
-extern int gfs2_writei(struct gfs2_inode *ip, void *buf, uint64_t offset,
-		       unsigned int size);
+#define gfs2_writei(ip, buf, offset, size) \
+	__gfs2_writei(ip, buf, offset, size, 1)
+extern int __gfs2_writei(struct gfs2_inode *ip, void *buf, uint64_t offset,
+			 unsigned int size, int resize);
 extern struct gfs2_buffer_head *get_file_buf(struct gfs2_inode *ip,
 					     uint64_t lbn, int prealloc);
 extern struct gfs2_buffer_head *init_dinode(struct gfs2_sbd *sdp,
diff --git a/gfs2/libgfs2/structures.c b/gfs2/libgfs2/structures.c
index 66a5733..7dabd80 100644
--- a/gfs2/libgfs2/structures.c
+++ b/gfs2/libgfs2/structures.c
@@ -324,10 +324,15 @@ int build_rindex(struct gfs2_sbd *sdp)
 		gfs2_rindex_out(&rl->ri, buf);
 
 		count = gfs2_writei(ip, buf, ip->i_di.di_size,
-							sizeof(struct gfs2_rindex));
+				    sizeof(struct gfs2_rindex));
 		if (count != sizeof(struct gfs2_rindex))
 			return -1;
 	}
+	memset(buf, 0, sizeof(struct gfs2_rindex));
+	count = __gfs2_writei(ip, buf, ip->i_di.di_size,
+			      sizeof(struct gfs2_rindex), 0);
+	if (count != sizeof(struct gfs2_rindex))
+		return -1;
 
 	if (sdp->debug) {
 		printf("\nResource Index:\n");
diff --git a/gfs2/mkfs/main_grow.c b/gfs2/mkfs/main_grow.c
index f95cb80..18110a0 100644
--- a/gfs2/mkfs/main_grow.c
+++ b/gfs2/mkfs/main_grow.c
@@ -16,6 +16,7 @@
 #include <errno.h>
 #include <stdarg.h>
 #include <linux/types.h>
+#include <linux/falloc.h>
 #include <libintl.h>
 #define _(String) gettext(String)
 
@@ -202,6 +203,7 @@ static void fix_rindex(struct gfs2_sbd *sdp, int rindex_fd, int old_rg_count)
 	char *buf, *bufptr;
 	osi_list_t *tmp;
 	ssize_t writelen;
+	struct stat statbuf;
 
 	/* Count the number of new RGs. */
 	rg = 0;
@@ -227,14 +229,52 @@ static void fix_rindex(struct gfs2_sbd *sdp, int rindex_fd, int old_rg_count)
 	gfs2_rgrp_free(&sdp->rglist);
 	fsync(sdp->device_fd);
 	if (!test) {
+		if (fstat(rindex_fd, &statbuf) != 0) {
+			log_crit("Can't stat rindex : %s\n", strerror(errno));
+			goto out;
+		}
+		if (statbuf.st_size !=
+		    old_rg_count * sizeof(struct gfs2_rindex)) {
+			log_crit("Incorrect rindex size. want %ld(%d RGs), "
+				 "have %ld\n",
+				 old_rg_count * sizeof(struct gfs2_rindex),
+				 old_rg_count, statbuf.st_size);
+			goto out;
+		}
 		/* Now write the new RGs to the end of the rindex */
 		lseek(rindex_fd, 0, SEEK_END);
-		count = write(rindex_fd, buf, writelen);
-		if (count != writelen)
+		count = write(rindex_fd, buf, sizeof(struct gfs2_rindex));
+		if (count != sizeof(struct gfs2_rindex)) {
+			log_crit("Error writing first new rindex entry;"
+				 "aborted.\n");
+			if (count > 0)
+				goto trunc;
+			else
+				goto out;
+		}
+		count = write(rindex_fd, buf + sizeof(struct gfs2_rindex),
+			      writelen - sizeof(struct gfs2_rindex));
+		if (count != writelen - sizeof(struct gfs2_rindex)) {
 			log_crit("Error writing new rindex entries;"
 				 "aborted.\n");
+			if (count > 0)
+				goto trunc;
+			else
+				goto out;
+		}
+		if (fallocate(rindex_fd, FALLOC_FL_KEEP_SIZE, statbuf.st_size + writelen, sizeof(struct gfs2_rindex)) != 0)
+			log_crit("Error fallocating extra space : %s\n",
+				 strerror(errno));
 		fsync(rindex_fd);
 	}
+out:
+	free(buf);
+	return;
+trunc:
+	count = (count / sizeof(struct gfs2_rindex)) + old_rg_count;
+	log_crit("truncating rindex to %ld\n",
+		 (off_t)count * sizeof(struct gfs2_rindex));
+	ftruncate(rindex_fd, (off_t)count * sizeof(struct gfs2_rindex));
 	free(buf);
 }
 
