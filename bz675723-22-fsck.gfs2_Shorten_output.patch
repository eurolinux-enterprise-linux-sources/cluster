commit 5a677ee1d50a8545b72113d1873bbc78898d8531
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Aug 9 11:38:18 2011 -0500

    fsck.gfs2: Shorten output
    
    This patch shortens some of the output of fsck.gfs2, thereby making
    the output files smaller and more manageable.
    
    rhbz#675723

diff --git a/gfs2/fsck/lost_n_found.c b/gfs2/fsck/lost_n_found.c
index 7886625..0de4f8e 100644
--- a/gfs2/fsck/lost_n_found.c
+++ b/gfs2/fsck/lost_n_found.c
@@ -66,8 +66,8 @@ static void add_dotdot(struct gfs2_inode *ip)
 				  (unsigned long long)ip->i_di.di_num.no_addr,
 				  (unsigned long long)di->dotdot_parent);
 		else
-			log_debug(_("Couldn't find a valid \"..\" entry "
-				    "for orphan directory %lld (0x%llx)\n"),
+			log_debug(_("Couldn't find directory %lld (0x%llx) "
+				    "in directory tree.\n"),
 				  (unsigned long long)ip->i_di.di_num.no_addr,
 				  (unsigned long long)ip->i_di.di_num.no_addr);
 	}
@@ -206,7 +206,7 @@ int add_inode_to_lf(struct gfs2_inode *ip){
 		incr_link_count(lf_dip->i_di.di_num.no_addr,
 				ip->i_di.di_mode, _("to lost+found"));
 
-	log_notice( _("Added inode #%llu (0x%llx) to lost+found dir\n"),
+	log_notice( _("Added inode #%llu (0x%llx) to lost+found\n"),
 		    (unsigned long long)ip->i_di.di_num.no_addr,
 		    (unsigned long long)ip->i_di.di_num.no_addr);
 	gfs2_dinode_out(&lf_dip->i_di, lf_dip->i_bh);
diff --git a/gfs2/fsck/metawalk.c b/gfs2/fsck/metawalk.c
index 9252aec..af27432 100644
--- a/gfs2/fsck/metawalk.c
+++ b/gfs2/fsck/metawalk.c
@@ -45,12 +45,13 @@ int check_n_fix_bitmap(struct gfs2_sbd *sdp, uint64_t blk,
 		const char *allocdesc[] = {"free space", "data", "unlinked",
 					   "inode", "reserved"};
 
-		log_err( _("Block %llu (0x%llx) seems to be %s, but is "
-			   "marked as %s in the bitmap.\n"),
+		/* Keep these messages as short as possible, or the output
+		   gets to be huge and unmanageable. */
+		log_err( _("Block %llu (0x%llx) was '%s', should be %s.\n"),
 			 (unsigned long long)blk, (unsigned long long)blk,
 			 allocdesc[new_bitmap_state],
 			 allocdesc[old_bitmap_state]);
-		if (query( _("Okay to fix the bitmap? (y/n)"))) {
+		if (query( _("Fix the bitmap? (y/n)"))) {
 			/* If the new bitmap state is free (and therefore the
 			   old state was not) we have to add to the free
 			   space in the rgrp. If the old bitmap state was
diff --git a/gfs2/fsck/pass5.c b/gfs2/fsck/pass5.c
index 1811e5a..028515b 100644
--- a/gfs2/fsck/pass5.c
+++ b/gfs2/fsck/pass5.c
@@ -79,8 +79,8 @@ static int check_block_status(struct gfs2_sbd *sdp, char *buffer, unsigned int b
 		   So we ignore it. */
 		if (rg_status == GFS2_BLKST_UNLINKED &&
 		    block_status == GFS2_BLKST_FREE) {
-			log_err( _("Unlinked inode block found at "
-				   "block %llu (0x%llx).\n"),
+			log_err( _("Unlinked inode found at block %llu "
+				   "(0x%llx).\n"),
 				 (unsigned long long)block,
 				 (unsigned long long)block);
 			if (query(_("Do you want to fix the bitmap? (y/n) "))) {
@@ -109,16 +109,17 @@ static int check_block_status(struct gfs2_sbd *sdp, char *buffer, unsigned int b
 			log_err( _("Ondisk status is %u (%s) but FSCK thinks it should be "),
 					rg_status, blockstatus[rg_status]);
 			log_err("%u (%s)\n", block_status, blockstatus[block_status]);
-			log_err( _("Metadata type is %u (%s)\n"), q,
-					block_type_string(q));
+			if (q) /* Don't print redundant "free" */
+				log_err( _("Metadata type is %u (%s)\n"), q,
+					 block_type_string(q));
 
 			if (query(_("Fix bitmap for block %llu (0x%llx) ? (y/n) "),
 				 (unsigned long long)block,
 				 (unsigned long long)block)) {
 				if (gfs2_set_bitmap(sdp, block, block_status))
-					log_err( _("Failed.\n"));
+					log_err( _("Repair failed.\n"));
 				else
-					log_err( _("Succeeded.\n"));
+					log_err( _("Fixed.\n"));
 			} else
 				log_err( _("Bitmap at block %"PRIu64" (0x%" PRIx64
 						") left inconsistent\n"), block, block);
